// ignore_for_file: avoid_print

/// Generates a Dart file with all 256 xterm ANSI colors and contrast information.
///
/// Run with: dart run tool/generate_xterm_colors.dart
library;

import 'dart:io';
import 'dart:math';

void main() {
  final buffer = StringBuffer();

  buffer.writeln('// GENERATED FILE - DO NOT EDIT');
  buffer.writeln('// Generated by tool/generate_xterm_colors.dart');
  buffer.writeln();
  buffer.writeln("import 'dart:math' as math;");
  buffer.writeln();
  buffer.writeln('/// Represents an xterm ANSI color with contrast information.');
  buffer.writeln('enum XtermColor {');

  // Generate enum values
  for (var i = 0; i < 256; i++) {
    final color = _getXtermColor(i);
    final luminance = _relativeLuminance(color.r, color.g, color.b);
    final contrastOnLight = _contrastRatio(luminance, 1.0); // white bg
    final contrastOnDark = _contrastRatio(luminance, 0.0); // black bg

    buffer.writeln('  ${color.name}(');
    buffer.writeln('    code: $i,');
    buffer.writeln('    r: ${color.r},');
    buffer.writeln('    g: ${color.g},');
    buffer.writeln('    b: ${color.b},');
    buffer.writeln('    luminance: ${luminance.toStringAsFixed(4)},');
    buffer.writeln('    contrastOnWhite: ${contrastOnLight.toStringAsFixed(2)},');
    buffer.writeln('    contrastOnBlack: ${contrastOnDark.toStringAsFixed(2)},');
    buffer.writeln('  ),');
  }

  // Add semicolon and fields
  buffer.writeln(';');
  buffer.writeln();
  buffer.writeln('  final int code;');
  buffer.writeln('  final int r;');
  buffer.writeln('  final int g;');
  buffer.writeln('  final int b;');
  buffer.writeln('  final double luminance;');
  buffer.writeln('  final double contrastOnWhite;');
  buffer.writeln('  final double contrastOnBlack;');
  buffer.writeln();
  buffer.writeln('  const XtermColor({');
  buffer.writeln('    required this.code,');
  buffer.writeln('    required this.r,');
  buffer.writeln('    required this.g,');
  buffer.writeln('    required this.b,');
  buffer.writeln('    required this.luminance,');
  buffer.writeln('    required this.contrastOnWhite,');
  buffer.writeln('    required this.contrastOnBlack,');
  buffer.writeln('  });');
  buffer.writeln();
  buffer.writeln('  /// Calculate color distance using CIEDE2000.');
  buffer.writeln('  ///');
  buffer.writeln('  /// Returns perceptual color difference (ΔE).');
  buffer.writeln('  static double distance(XtermColor a, XtermColor b) {');
  buffer.writeln('    // Convert RGB to Lab');
  buffer.writeln('    final lab1 = _rgbToLab(a.r, a.g, a.b);');
  buffer.writeln('    final lab2 = _rgbToLab(b.r, b.g, b.b);');
  buffer.writeln('    return _ciede2000(lab1, lab2);');
  buffer.writeln('  }');
  buffer.writeln();
  buffer.writeln('  static (double L, double a, double b) _rgbToLab(int r, int g, int b) {');
  buffer.writeln('    // RGB to XYZ');
  buffer.writeln('    double pivotRgb(double n) {');
  buffer.writeln('      final v = n / 255.0;');
  buffer.writeln('      return v > 0.04045 ? math.pow((v + 0.055) / 1.055, 2.4).toDouble() : v / 12.92;');
  buffer.writeln('    }');
  buffer.writeln('    final rLinear = pivotRgb(r.toDouble()) * 100;');
  buffer.writeln('    final gLinear = pivotRgb(g.toDouble()) * 100;');
  buffer.writeln('    final bLinear = pivotRgb(b.toDouble()) * 100;');
  buffer.writeln();
  buffer.writeln('    // Observer = 2°, Illuminant = D65');
  buffer.writeln('    final x = rLinear * 0.4124564 + gLinear * 0.3575761 + bLinear * 0.1804375;');
  buffer.writeln('    final y = rLinear * 0.2126729 + gLinear * 0.7151522 + bLinear * 0.0721750;');
  buffer.writeln('    final z = rLinear * 0.0193339 + gLinear * 0.1191920 + bLinear * 0.9503041;');
  buffer.writeln();
  buffer.writeln('    // XYZ to Lab');
  buffer.writeln('    const refX = 95.047;');
  buffer.writeln('    const refY = 100.000;');
  buffer.writeln('    const refZ = 108.883;');
  buffer.writeln();
  buffer.writeln('    double pivotXyz(double n) {');
  buffer.writeln('      return n > 0.008856 ? math.pow(n, 1.0 / 3.0).toDouble() : (7.787 * n) + (16.0 / 116.0);');
  buffer.writeln('    }');
  buffer.writeln();
  buffer.writeln('    final xPivot = pivotXyz(x / refX);');
  buffer.writeln('    final yPivot = pivotXyz(y / refY);');
  buffer.writeln('    final zPivot = pivotXyz(z / refZ);');
  buffer.writeln();
  buffer.writeln('    final labL = (116.0 * yPivot) - 16.0;');
  buffer.writeln('    final labA = 500.0 * (xPivot - yPivot);');
  buffer.writeln('    final labB = 200.0 * (yPivot - zPivot);');
  buffer.writeln();
  buffer.writeln('    return (labL, labA, labB);');
  buffer.writeln('  }');
  buffer.writeln();
  buffer.writeln('  static double _ciede2000(');
  buffer.writeln('    (double, double, double) lab1,');
  buffer.writeln('    (double, double, double) lab2,');
  buffer.writeln('  ) {');
  buffer.writeln('    final l1 = lab1.\$1;');
  buffer.writeln('    final a1 = lab1.\$2;');
  buffer.writeln('    final b1 = lab1.\$3;');
  buffer.writeln('    final l2 = lab2.\$1;');
  buffer.writeln('    final a2 = lab2.\$2;');
  buffer.writeln('    final b2 = lab2.\$3;');
  buffer.writeln();
  buffer.writeln('    const kL = 1.0;');
  buffer.writeln('    const kC = 1.0;');
  buffer.writeln('    const kH = 1.0;');
  buffer.writeln('    const pi = 3.141592653589793;');
  buffer.writeln();
  buffer.writeln('    final c1 = math.sqrt(a1 * a1 + b1 * b1);');
  buffer.writeln('    final c2 = math.sqrt(a2 * a2 + b2 * b2);');
  buffer.writeln('    final cBar = (c1 + c2) / 2;');
  buffer.writeln();
  buffer.writeln('    final cBar7 = cBar * cBar * cBar * cBar * cBar * cBar * cBar;');
  buffer.writeln('    final g = 0.5 * (1 - math.sqrt(cBar7 / (cBar7 + 6103515625)));');
  buffer.writeln();
  buffer.writeln('    final a1Prime = a1 * (1 + g);');
  buffer.writeln('    final a2Prime = a2 * (1 + g);');
  buffer.writeln();
  buffer.writeln('    final c1Prime = math.sqrt(a1Prime * a1Prime + b1 * b1);');
  buffer.writeln('    final c2Prime = math.sqrt(a2Prime * a2Prime + b2 * b2);');
  buffer.writeln();
  buffer.writeln('    var h1Prime = math.atan2(b1, a1Prime) * 180 / pi;');
  buffer.writeln('    if (h1Prime < 0) h1Prime += 360;');
  buffer.writeln('    var h2Prime = math.atan2(b2, a2Prime) * 180 / pi;');
  buffer.writeln('    if (h2Prime < 0) h2Prime += 360;');
  buffer.writeln();
  buffer.writeln('    final deltaLPrime = l2 - l1;');
  buffer.writeln('    final deltaCPrime = c2Prime - c1Prime;');
  buffer.writeln();
  buffer.writeln('    double deltahPrime;');
  buffer.writeln('    if (c1Prime * c2Prime == 0) {');
  buffer.writeln('      deltahPrime = 0;');
  buffer.writeln('    } else {');
  buffer.writeln('      final diff = h2Prime - h1Prime;');
  buffer.writeln('      if (diff.abs() <= 180) {');
  buffer.writeln('        deltahPrime = diff;');
  buffer.writeln('      } else if (diff > 180) {');
  buffer.writeln('        deltahPrime = diff - 360;');
  buffer.writeln('      } else {');
  buffer.writeln('        deltahPrime = diff + 360;');
  buffer.writeln('      }');
  buffer.writeln('    }');
  buffer.writeln();
  buffer.writeln('    final deltaHPrime =');
  buffer.writeln('        2 * math.sqrt(c1Prime * c2Prime) * math.sin(deltahPrime * pi / 360);');
  buffer.writeln();
  buffer.writeln('    final lBarPrime = (l1 + l2) / 2;');
  buffer.writeln('    final cBarPrime = (c1Prime + c2Prime) / 2;');
  buffer.writeln();
  buffer.writeln('    double hBarPrime;');
  buffer.writeln('    if (c1Prime * c2Prime == 0) {');
  buffer.writeln('      hBarPrime = h1Prime + h2Prime;');
  buffer.writeln('    } else if ((h1Prime - h2Prime).abs() <= 180) {');
  buffer.writeln('      hBarPrime = (h1Prime + h2Prime) / 2;');
  buffer.writeln('    } else if (h1Prime + h2Prime < 360) {');
  buffer.writeln('      hBarPrime = (h1Prime + h2Prime + 360) / 2;');
  buffer.writeln('    } else {');
  buffer.writeln('      hBarPrime = (h1Prime + h2Prime - 360) / 2;');
  buffer.writeln('    }');
  buffer.writeln();
  buffer.writeln('    final t = 1 -');
  buffer.writeln('        0.17 * math.cos((hBarPrime - 30) * pi / 180) +');
  buffer.writeln('        0.24 * math.cos(2 * hBarPrime * pi / 180) +');
  buffer.writeln('        0.32 * math.cos((3 * hBarPrime + 6) * pi / 180) -');
  buffer.writeln('        0.20 * math.cos((4 * hBarPrime - 63) * pi / 180);');
  buffer.writeln();
  buffer.writeln('    final deltaTheta =');
  buffer.writeln('        30 * math.exp(-((hBarPrime - 275) / 25) * ((hBarPrime - 275) / 25));');
  buffer.writeln();
  buffer.writeln('    final cBarPrime7 =');
  buffer.writeln('        cBarPrime * cBarPrime * cBarPrime * cBarPrime * cBarPrime * cBarPrime * cBarPrime;');
  buffer.writeln('    final rc = 2 * math.sqrt(cBarPrime7 / (cBarPrime7 + 6103515625));');
  buffer.writeln();
  buffer.writeln('    final lBarPrimeMinus50Sq = (lBarPrime - 50) * (lBarPrime - 50);');
  buffer.writeln('    final sl =');
  buffer.writeln('        1 + (0.015 * lBarPrimeMinus50Sq) / math.sqrt(20 + lBarPrimeMinus50Sq);');
  buffer.writeln('    final sc = 1 + 0.045 * cBarPrime;');
  buffer.writeln('    final sh = 1 + 0.015 * cBarPrime * t;');
  buffer.writeln('    final rt = -math.sin(2 * deltaTheta * pi / 180) * rc;');
  buffer.writeln();
  buffer.writeln('    final dL = deltaLPrime / (kL * sl);');
  buffer.writeln('    final dC = deltaCPrime / (kC * sc);');
  buffer.writeln('    final dH = deltaHPrime / (kH * sh);');
  buffer.writeln();
  buffer.writeln('    return math.sqrt(dL * dL + dC * dC + dH * dH + rt * dC * dH);');
  buffer.writeln('  }');
  buffer.writeln('}');

  final outputFile = File('lib/src/xterm_colors.g.dart');
  outputFile.writeAsStringSync(buffer.toString());
  print('Generated ${outputFile.path}');
}

class _ColorInfo {
  final String name;
  final int r;
  final int g;
  final int b;

  const _ColorInfo(this.name, this.r, this.g, this.b);
}

_ColorInfo _getXtermColor(int code) {
  // Standard colors (0-15)
  const standardColors = [
    _ColorInfo('black', 0, 0, 0),
    _ColorInfo('red', 128, 0, 0),
    _ColorInfo('green', 0, 128, 0),
    _ColorInfo('yellow', 128, 128, 0),
    _ColorInfo('blue', 0, 0, 128),
    _ColorInfo('magenta', 128, 0, 128),
    _ColorInfo('cyan', 0, 128, 128),
    _ColorInfo('white', 192, 192, 192),
    _ColorInfo('brightBlack', 128, 128, 128),
    _ColorInfo('brightRed', 255, 0, 0),
    _ColorInfo('brightGreen', 0, 255, 0),
    _ColorInfo('brightYellow', 255, 255, 0),
    _ColorInfo('brightBlue', 0, 0, 255),
    _ColorInfo('brightMagenta', 255, 0, 255),
    _ColorInfo('brightCyan', 0, 255, 255),
    _ColorInfo('brightWhite', 255, 255, 255),
  ];

  if (code < 16) {
    final c = standardColors[code];
    return _ColorInfo(c.name, c.r, c.g, c.b);
  }

  // 216 color cube (16-231)
  if (code < 232) {
    final index = code - 16;
    final r = (index ~/ 36) % 6;
    final g = (index ~/ 6) % 6;
    final b = index % 6;

    int toRgb(int v) => v == 0 ? 0 : 55 + v * 40;

    return _ColorInfo('color$code', toRgb(r), toRgb(g), toRgb(b));
  }

  // Grayscale (232-255)
  final gray = 8 + (code - 232) * 10;
  return _ColorInfo('gray${code - 232}', gray, gray, gray);
}

/// Calculate relative luminance using WCAG formula.
double _relativeLuminance(int r, int g, int b) {
  double toLinear(int c) {
    final v = c / 255.0;
    return v <= 0.03928 ? v / 12.92 : pow((v + 0.055) / 1.055, 2.4).toDouble();
  }

  return 0.2126 * toLinear(r) + 0.7152 * toLinear(g) + 0.0722 * toLinear(b);
}

/// Calculate contrast ratio using WCAG formula.
double _contrastRatio(double fgLuminance, double bgLuminance) {
  final lighter = max(fgLuminance, bgLuminance);
  final darker = min(fgLuminance, bgLuminance);
  return (lighter + 0.05) / (darker + 0.05);
}
